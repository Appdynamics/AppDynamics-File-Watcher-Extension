var beansPackage = Packages.com.singularity.ee.controller.beans;
var context = beansPackage.ContextImpl.getInstance();
  
function getDataSource() {
 return context.getDataSource();
}
  
function logToServerLog(str) {
 java.lang.System.err.println(str);
}
  
var dryRun = <Set to "true" to see the metrics that match the below filters and "false" to delete the matched metrics>;
var hoursStale = <No.of days since the metrics have not reported> * 24;
var entityType = com.appdynamics.platform.libraries.metricactivity.api.MetricActivityTracker.EntityType.APPLICATION;
var appId = <Application ID>;
var metricNamePatterns = ['<Metric Pattern>'];
var batchSize;
if (dryRun) {
 batchSize = new java.lang.Integer(10000000000);
} else {
 batchSize = new java.lang.Integer(5000);
}
var useBlitz = false;
var metricTable = "metricdata_hour_agg_app"; // leave empty if blitz enabled, otherwise use "metricdata_hour_agg_app"
  
var staleMetricsQueryBuilder = new com.singularity.ee.controller.beans.util.metrics.StaleMetricsQueryBuilder();
staleMetricsQueryBuilder.withHoursStale(hoursStale);
staleMetricsQueryBuilder.withApplicationId(appId);
staleMetricsQueryBuilder.withMetricNamePatterns(metricNamePatterns);
var staleMetricsQuery = staleMetricsQueryBuilder.build(useBlitz, batchSize, metricTable);
var metricActivityTracker = com.appdynamics.platform.GuiceEJBInjectorHolder.getInjector().getInstance(Packages.com.appdynamics.platform.libraries.metricactivity.MetricActivityTrackerImpl.class);
var mqmb = context.getGlobalBeanInstance(Packages.com.appdynamics.metric.query.IMetricQueryManagerInternal.class);
  
function getOneBatchOfMetrics() {
 var batch = new java.util.HashSet();
 var connection = getDataSource().getConnection();
 try {
 var st = connection.createStatement();
 var rs = st.executeQuery(staleMetricsQuery);
 while(rs.next()) {
 batch.add(new java.lang.Long(rs.getLong(1)));
 }
 } finally {
 connection.close();
 }
 if(useBlitz) {
 var staleMetrics = metricActivityTracker.getStaleMetrics(entityType, appId, batch, hoursStale);
 return staleMetrics;
 }
 return batch;
}
  
function work() {
 logToServerLog("IDXYZzzz Start deleting custom metrics with query: {" + staleMetricsQuery + "}");
 var batch = getOneBatchOfMetrics();
 while (!batch.isEmpty()) {
 mqmb.deleteMetricsWithReferencesInternal(batch);
 logToServerLog("IDXYZzzz Metrics deleted: " + batch.size());
 batch.clear();
 java.lang.Thread.sleep(100);
 batch = getOneBatchOfMetrics();
 }
 logToServerLog("IDXYZzzz Finished deleting custom stale metrics");
}
  
function main() {
 var r = new java.lang.Runnable() {
 run: function() {
 work();
 }
 }
 var t = new java.lang.Thread(r, "Inspector Thread");
 t.start();
}
  
var result = new java.util.ArrayList();
if (dryRun) {
 var batch = getOneBatchOfMetrics();
 result.add("DRY RUN :" + batch.size() + " metrics will be purged");
 logToServerLog("IDXYZzzz DRY RUN:" + batch.size() + " metrics will be purged");
 var count = 1;
 var itr = batch.iterator();
 while (itr.hasNext()) {
 result.add(itr.next());
 }
 result;
} else {
 result.add("Purge thread has started");
 main();
 result;
}